"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var merge_styles_1 = require("@uifabric/merge-styles");
var MAX_CACHE_COUNT = 50;
// Note that because of the caching nature within the classNames memoization,
// I've disabled this rule to simply be able to work with any types.
// tslint:disable:no-any
// This represents a prop we attach to each Map to indicate the cached return value
// associated with the graph node.
var RetVal = '__retval__';
/**
 * Creates a getClassNames function which calls getStyles given the props, and injects them
 * into mergeStyleSets.
 *
 * Note that the props you pass in on every render should be in the same order and
 * immutable (numbers, strings, and booleans). This will allow the results to be memoized. Violating
 * these will cause extra recalcs to occur.
 */
function classNamesFunction(options) {
    // We build a trie where each node is a Map. The map entry key represents an argument
    // value, and the entry value is another node (Map). Each node has a `__retval__`
    // property which is used to hold the cached response.
    if (options === void 0) { options = {}; }
    // To derive the response, we can simply ensure the arguments are added or already
    // exist in the trie. At the last node, if there is a `__retval__` we return that. Otherwise
    // we call the `getStyles` api to evaluate, cache on the property, and return that.
    var map = new Map();
    var resultCount = 0;
    var getClassNames = function (styleFunctionOrObject, styleProps) {
        if (styleProps === void 0) { styleProps = {}; }
        var current = map;
        var disableCaching = options.disableCaching;
        if (!options.disableCaching) {
            current = _traverseMap(map, styleFunctionOrObject);
            current = _traverseMap(current, styleProps);
        }
        if (disableCaching || !current[RetVal]) {
            if (styleFunctionOrObject === undefined) {
                current[RetVal] = {};
            }
            else if (Array.isArray(styleFunctionOrObject)) {
                current[RetVal] = merge_styles_1.mergeStyleSets.apply(void 0, styleFunctionOrObject.map(_derive, styleProps));
            }
            else {
                current[RetVal] = merge_styles_1.mergeStyleSets(typeof styleFunctionOrObject === 'function' ? styleFunctionOrObject(styleProps) : styleFunctionOrObject);
            }
            if (!disableCaching) {
                resultCount++;
            }
        }
        if (resultCount > MAX_CACHE_COUNT) {
            map.clear();
            resultCount = 0;
            // Mutate the options passed in, that's all we can do.
            options.disableCaching = true;
            // Note: this code is great for debugging problems with styles being recaculated, but commenting it out
            // to avoid confusing consumers.
            // if (process.env.NODE_ENV !== 'production') {
            //  console.log('Styles are being recalculated far too frequently. Something is mutating the class over and over.');
            //  // tslint:disable-next-line:no-console
            //  console.trace();
            // }
        }
        // Note: the RetVal is an attached property on the Map; not a key in the Map. We use this attached property to
        // cache the return value for this branch of the graph.
        return current[RetVal];
    };
    return getClassNames;
}
exports.classNamesFunction = classNamesFunction;
function _derive(obj) {
    return typeof obj === 'function' ? obj(this) : obj;
}
function _traverseEdge(current, value) {
    value = _normalizeValue(value);
    if (!current.has(value)) {
        current.set(value, new Map());
    }
    return current.get(value);
}
function _traverseMap(current, inputs) {
    if (Array.isArray(inputs)) {
        for (var i = 0; i < inputs.length; i++) {
            current = _traverseEdge(current, inputs[i]);
        }
    }
    else if (typeof inputs === 'object') {
        for (var propName in inputs) {
            if (inputs.hasOwnProperty(propName)) {
                current = _traverseEdge(current, inputs[propName]);
            }
        }
    }
    return current;
}
function _normalizeValue(value) {
    switch (value) {
        case undefined:
            return '__undefined__';
        case null:
            return '__null__';
        default:
            return value;
    }
}
//# sourceMappingURL=classNamesFunction.js.map